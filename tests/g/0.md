╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                            [1mLecture 0: Pong[0m                                                             ║
╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝


                                                              [1;4mToday’s Topics[0m                                                              

[1;33m • [0mLua                                                                                                                                    
[1;33m   [0m[1;33m • [0mThis is the programming language that we’ll be using predominantly throughout the course. Lua is a dynamic scripting language       
[1;33m   [0m[1;33m   [0msimilar to Python and JavaScript.                                                                                                   
[1;33m • [0mLÖVE2D                                                                                                                                 
[1;33m   [0m[1;33m • [0mThe primary game framework we’ll be using throughout the course. It works hand in hand with Lua, and you can find documentation for 
[1;33m   [0m[1;33m   [0mit at ]8;id=903390;https://love2d.org/wiki/Main_Page\[94mlove2d.org/wiki/Main[0m]8;;\]8;id=903390;https://love2d.org/wiki/Main_Page\[94m_[0m]8;;\]8;id=903390;https://love2d.org/wiki/Main_Page\[94mPage[0m]8;;\ .                                                                                                   
[1;33m • [0mDrawing Shapes and Text                                                                                                                
[1;33m   [0m[1;33m • [0mTwo of the most basic principles of game development, being able to draw shapes and text is what will allow us to render our game on
[1;33m   [0m[1;33m   [0ma screen.                                                                                                                           
[1;33m • [0mDeltaTime and Velocity                                                                                                                 
[1;33m   [0m[1;33m • [0mDeltaTime, arguably one of the most important variables that we keep track of in any game framework, is the time elapsed since the  
[1;33m   [0m[1;33m   [0mlast frame of execution in our game. LÖVE2D measures DeltaTime in terms of seconds, so we’ll see how this concept relates to        
[1;33m   [0m[1;33m   [0mvelocity.                                                                                                                           
[1;33m • [0mGame State                                                                                                                             
[1;33m   [0m[1;33m • [0mEvery game is composed of a series of states (e.g., the title screen state, gameplay state, menu state, etc.), so it will be        
[1;33m   [0m[1;33m   [0mimportant to understand this concept since we’ll want different rendering logic and update logic for each state.                    
[1;33m • [0mBasic OOP (Object-Oriented Programming)                                                                                                
[1;33m   [0m[1;33m • [0mThe use of Object-Oriented Programming will allow us to encapsulate our data and game objects such that each object in our game will
[1;33m   [0m[1;33m   [0mbe able to keep track of all the information that is relevant to it, as well as have access to specific functions that are unique to
[1;33m   [0m[1;33m   [0mit.                                                                                                                                 
[1;33m • [0mBox Collision (Hitboxes)                                                                                                               
[1;33m   [0m[1;33m • [0mUnderstanding the concept of box collision will be necessary in order to bring Pong to life, since we’ll need to be able to “bounce”
[1;33m   [0m[1;33m   [0ma ball back and forth between two paddles. The ball and paddles will be rectangular, so we’ll focus on “Axis-Aligned Bounding       
[1;33m   [0m[1;33m   [0mBoxes,” which will allow us to calculate collisions more simply.                                                                    
[1;33m • [0mSound Effects (with bfxr)                                                                                                              
[1;33m   [0m[1;33m • [0mLastly, we’ll learn how to polish up our game with sound effects in order to make it more enticing and immersive.                   


                                                            [1;4mInstalling LÖVE2D[0m                                                             

[1;33m • [0mBefore you start following along with the rest of the lecture, be sure to have LÖVE2D installed on your machine, which you can do      
[1;33m   [0mthrough the following link:                                                                                                            
[1;33m   [0m[1;33m • [0m]8;id=59862;https://love2d.org/#download\[94mlove2d.org/#download[0m]8;;\ .                                                                                                              
[1;33m • [0mIt’s available for all major operating systems (Windows, Mac, Linux). If you’re in need of some tips for how to get it started running 
[1;33m   [0mon your machine, check out this link:                                                                                                  
[1;33m   [0m[1;33m • [0m]8;id=825028;https://love2d.org/wiki/Getting_Started\[94mlove2d.org/wiki/Getting[0m]8;;\]8;id=825028;https://love2d.org/wiki/Getting_Started\[94m_[0m]8;;\]8;id=825028;https://love2d.org/wiki/Getting_Started\[94mStarted[0m]8;;\ .                                                                                                   


                                                          [1;4mDownloading Demo Code[0m                                                           

[1;33m • [0mNext, be sure to download the code for today’s lecture, which you can find at:                                                         
[1;33m   [0m[1;33m • [0m]8;id=764554;https://github.com/games50/pong\[94mgithub.com/games50/pong[0m]8;;\ .                                                                                                           
[1;33m • [0mThis should make it easier to follow along without having to focus on matching every keystroke in real time.                           


                                                               [1;4mWhat is Lua?[0m                                                               

[1;33m • [0m“Lua” is Portuguese for “moon.” It was invented in 1993 in Brazil, and is intended for embedded use in larger applications. Since its  
[1;33m   [0minvention, it has become very popular in the video game industry.                                                                      
[1;33m • [0mIt is a flexible, lightweight scripting language focused around “tables,” which are similar to dictionaries in Python and objects in   
[1;33m   [0mJavaScript.                                                                                                                            
[1;33m • [0mLua is excellent for storing data as well as code (it benefits from a data-driven design).                                             


                                                             [1;4mWhat is LÖVE2D?[0m                                                              

[1;33m • [0mLÖVE2D is a fast 2D game development framework written in C++ that uses Lua as its scripting language.                                 
[1;33m • [0mIt contains modules for graphics, keyboard input, math, audio, windowing, physics, and much more.                                      
[1;33m • [0mFortunately, it is completely free and portable to all major desktops and Android/iOS.                                                 
[1;33m • [0mIt’s also great for prototyping if you don’t plan on using LÖVE2D in the final version of your game!                                   


                                                           [1;4mWhat is a game loop?[0m                                                           

🌆 ]8;id=129832;game_loop.png\game_loop.png]8;;\ 
[1;33m • [0mA game, fundamentally, is an infinite loop, like a [97;40mwhile(true)[0m or a [97;40mwhile(1)[0m . During every iteration of that loop, we’re repeatedly   
[1;33m   [0mperforming the following set of steps:                                                                                                 
[1;33m   [0m[1;33m • [0mFirst, we’re processing input. That is to say, we’re constantly checking: has the user pressed a key on the keyboard, moved the     
[1;33m   [0m[1;33m   [0mjoystick, moved/clicked the mouse, etc.?                                                                                            
[1;33m   [0m[1;33m • [0mSecond, we need to respond to that input from the previous step by updating anything in the game that depends on that input (i.e.,  
[1;33m   [0m[1;33m   [0mtracking movement, detecting collisions, etc.).                                                                                     
[1;33m   [0m[1;33m • [0mThird, we need to re-render anything that was updated in the previous step, so that the user can see visually on the screen that the
[1;33m   [0m[1;33m   [0mgame has changed and feel a sense of interactivity.                                                                                 

Photo taken from ]8;id=373119;http://gameprogrammingpatterns.com/game-loop.html\[94mgameprogrammingpatterns.com/game-loop.html[0m]8;;\ , where you can read more about game loops.                                   


                                                           [1;4m2D Coordinate System[0m                                                           

[1;33m • [0mIn the context of 2D games, the most fundamental way of looking at the world is by using the 2D coordinate system.                     
[1;33m • [0mSlightly different from the traditional coordinate system you might’ve used in math class, the 2D coordinate system we’re referring to 
[1;33m   [0mhere is a system in which objects have an X and Y coordinate (X, Y) and are drawn accordingly, with (0,0) being the top-left of the    
[1;33m   [0msystem. This means positive directions moving down and to the right, while negative directions move up and to the left.                

🌆 ]8;id=129470;2D_coordinate_system.png\2D_coordinate_system.png]8;;\                                                                                                               

Photo taken from ]8;id=726090;http://rbwhitaker.wdfiles.com/local--files/monogame-introduction-to-2d-graphics/2DCoordinateSystem.png\[94mrbwhitaker.wdfiles.com/local--files/monogame-introduction-to-2d-graphics/2DCoordinateSystem.png[0m]8;;\ .                        


                                                               [1;4mToday’s Goal[0m                                                               

[1;33m • [0mWe are aiming to recreate “Pong,” a simple 2 player game in which one player has a paddle on the left side of the screen, the other    
[1;33m   [0mplayer has a paddle on the right side of the screen, and the first player to score 10 times on their opponent wins. A player scores by 
[1;33m   [0mgetting the ball past the opponent’s paddle and into their “goal” (i.e., the edge of the screen).                                      

🌆 ]8;id=365313;pong_example.png\pong_example.png]8;;\                                                                                                                       


                                                             [1;4mLecture’s Scope[0m                                                              

[1;33m • [0mFirst off, we’ll want to draw shapes to the screen (e.g., paddles and ball) so that the user can see the game.                         
[1;33m • [0mNext, we’ll want to control the 2D position of the paddles based on input, and implement collision detection between the paddles and   
[1;33m   [0mball so that each player can deflect the ball back toward their opponent.                                                              
[1;33m • [0mWe’ll also need to implement collision detection between the ball and screen boundaries to keep the ball within the vertical bounds of 
[1;33m   [0mthe screen and to detect scoring events (outside horizontal bounds)                                                                    
[1;33m • [0mAt that point, we’ll want to add sound effects for when the ball hits paddles and walls, and for when a point is scored.               
[1;33m • [0mLastly, we’ll display the score on the screen so that the players don’t have to remember it during the game.                           


                                                       [1;4mpong-0 (“The Day-0 Update”)[0m                                                        

[1;33m • [0mAt this point, you will want to have downloaded the demo code in order to follow along. Be sure to pay attention to the comments in the
[1;33m   [0mcode!                                                                                                                                  
[1;33m • [0mpong-0 simply prints “Hello Pong!” exactly in the center of the screen. This is not incredibly exciting, but it does showcase how to   
[1;33m   [0muse LÖVE2D’s most important functions moving forward.                                                                                  

                                                                                                                                          

Important Functions                                                                                                                       

[1;33m • [0m[97;40mlove.load()[0m                                                                                                                            
[1;33m   [0m[1;33m • [0mThis function is used for initializing our game state at the very beginning of program execution. Whatever code we put here will be 
[1;33m   [0m[1;33m   [0mexecuted once at the very beginning of the program.                                                                                 
[1;33m • [0m[97;40mlove.update(dt)[0m                                                                                                                        
[1;33m   [0m[1;33m • [0mThis function is called by LÖVE at each frame of program execution; [97;40mdt[0m (i.e., DeltaTime) will be the elapsed time in seconds since  
[1;33m   [0m[1;33m   [0mthe last frame, and we can use this to scale any changes in our game for even behavior across frame rates.                          
[1;33m • [0m[97;40mlove.draw()[0m                                                                                                                            
[1;33m   [0m[1;33m • [0mThis function is also called at each frame by LÖVE. It is called after the update step completes so that we can draw things to the  
[1;33m   [0m[1;33m   [0mscreen once they’ve changed.                                                                                                        
[1;33m • [0mLÖVE2D expects these functions to be implemented in [97;40mmain.lua[0m and calls them internally; if we don’t define them, it will still         
[1;33m   [0mfunction, but our game will be fundamentally incomplete, at least if [97;40mupdate[0m or [97;40mdraw[0m are missing! We’ll take a look at two more         
[1;33m   [0mfunctions below:                                                                                                                       
[1;33m • [0m[97;40mlove.graphics.printf(text, x, y, [width], [align])[0m                                                                                     
[1;33m   [0m[1;33m • [0mVersatile print function that can align text left, right, or center on the screen                                                   
[1;33m • [0m[97;40mlove.window.setMode(width, height, params)[0m                                                                                             
[1;33m   [0m[1;33m • [0mUsed to initialize the window’s dimensions and to set parameters like [97;40mvsync[0m (vertical sync), whether we’re fullscreen or not, and   
[1;33m   [0m[1;33m   [0mwhether the window is resizeable after startup. We won’t be using this function past this example in favor of the [97;40mpush[0m virtual      
[1;33m   [0m[1;33m   [0mresolution library, which has its own method like this, but it is useful to know if encountered in other code.                      
[1;33m • [0mNow, with these puzzle pieces in mind, you can see how we’re rendering “Hello Pong!” to the center of the screen:                      

                                                                                                                                          

Important code                                                                                                                            

[1;33m • [0mWe initialize our game by specifying in the [97;40mlove.load()[0m function that our 1280x720 game window shouldn’t be fullscreen or resizable,   
[1;33m   [0mbut it should be synced to our monitor’s own refresh rate.                                                                             

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  WINDOW\_WIDTH = 1280                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  WINDOW\_HEIGHT = 720                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  function love.load()                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.window.setMode(WINDOW\_WIDTH, WINDOW\_HEIGHT, {                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          fullscreen = false,                                                                                                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          resizable = false,                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          vsync = true                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      })                                                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

[1;33m • [0mNext, we overwrite [97;40mlove.draw()[0m so that we can specify the text we’d like to render to the screen, in this case “Hello Pong!”, along    
[1;33m   [0mwith coordinates for where it should be drawn.                                                                                         

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  function love.draw()                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.printf(                                                                                                           [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          'Hello Pong!',                                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          0,                                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          WINDOW\_HEIGHT / 2 - 6,                                                                                                     [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          WINDOW\_WIDTH,                                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          'center')                                                                                                                   [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m


                                                      [1;4mpong-1 (“The Low-Res Update”)[0m                                                       

[1;33m • [0mpong-1 exhibits the same behavior as pong-0, but with much blurrier text.                                                              

                                                                                                                                          

Important Functions                                                                                                                       

[1;33m • [0m[97;40mlove.graphics.setDefaultFilter(min, mag)[0m                                                                                               
[1;33m   [0m[1;33m • [0mThis function sets the texture scaling filter when minimizing and magnifying textures and fonts; LÖVE’s default is bilinear, which  
[1;33m   [0m[1;33m   [0mcauses blurriness, but for our use cases we will typically want nearest-neighbor filtering ( [97;40mnearest[0m ), which results in perfect    
[1;33m   [0m[1;33m   [0mpixel upscaling and downscaling, simulating a retro feel.                                                                           
[1;33m • [0m[97;40mlove.keypressed(key)[0m                                                                                                                   
[1;33m   [0m[1;33m • [0mThis is a LÖVE2D callback function that executes whenever we press a key, assuming we’ve implemented this in [97;40mmain.lua[0m , in the same 
[1;33m   [0m[1;33m   [0mvein as [97;40mlove.load()[0m , [97;40mlove.update(dt)[0m , and [97;40mlove.draw()[0m . It’ll allow us to receive input from the keyboard for our game.           
[1;33m • [0m[97;40mlove.event.quit()[0m                                                                                                                      
[1;33m   [0m[1;33m • [0mThis is a simple function that terminates the application upon execution.                                                           

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mWhen you open pong-1, you’ll notice that we’ve begun using the [97;40mpush[0m library we referred to earlier. You can “import” other files in    
[1;33m   [0myour [97;40mmain.lua[0m file with the [97;40mrequire[0m keyword given that they are in the same directory.                                                 
[1;33m • [0mIn addition, we’ve also added two new variables to the code:                                                                           

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  push = require 'push'                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  WINDOW\_WIDTH = 1280                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  WINDOW\_HEIGHT = 720                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  VIRTUAL\_WIDTH = 432                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  VIRTUAL\_HEIGHT = 243                                                                                                               [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

This will allow us to think of our game in more low-res terms, by using the [97;40mpush[0m library to treat our game as if it were on a 432x243     
window, while actually rendering it at our desired 1280x720 window. With this change, we can see we’ve updated our [97;40mlove.load()[0m function   
accordingly:                                                                                                                              

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  function love.load()                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.setDefaultFilter('nearest', 'nearest')                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      push:setupScreen(VIRTUAL\_WIDTH, VIRTUAL\_HEIGHT, WINDOW\_WIDTH, WINDOW\_HEIGHT, {                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          fullscreen = false,                                                                                                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          resizable = false,                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          vsync = true                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      })                                                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

[1;33m • [0mWe’ve also added a way to quit the game via user input, by using two of the functions discussed above:                                 

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  function love.keypressed(key)                                                                                                       [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      if key == 'escape' then                                                                                                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          love.event.quit()                                                                                                           [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

Including this code in [97;40mmain.lua[0m will ensure that the program is always monitoring whether the user has pressed the [97;40mescape[0m key on their    
keyboard, in which case [97;40mlove.event.quit()[0m will be called to terminate the program.                                                        

[1;33m • [0mLastly, we’ve made a small tweak to our [97;40mlove.draw()[0m function so as to integrate the [97;40mpush[0m library into the code.                        

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  function love.draw()                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      push:apply('start')                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.printf('Hello Pong!', 0, VIRTUAL\_HEIGHT / 2 - 6, VIRTUAL\_WIDTH, 'center')                                       [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      push:apply('end')                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

You’ll notice that our print statement remains unchanged, but we’ve wrapped it between [97;40mpush:apply('start')[0m and [97;40mpush:apply('end')[0m to ensure
that its contents will be rendered at our desired virtual resolution.                                                                     

[1;33m • [0mWith these changes, you’ll notice that while we’re still printing “Hello Pong!” to the center of the screen, the text is now magnified 
[1;33m   [0mand rendered at a lower resolution, despite our window size being the same as before.                                                  


                                                     [1;4mpong-2 (“The Rectangle Update”)[0m                                                      

[1;33m • [0mpong-2 produces a more complete, albeit static image of what our Pong program should look like.                                        

                                                                                                                                          

Important Functions                                                                                                                       

[1;33m • [0m[97;40mlove.graphics.newFont(path, size)[0m                                                                                                      
[1;33m   [0m[1;33m • [0mThis function loads a font file into memory at a specific path, setting it to a specific size, and storing it in an object we can   
[1;33m   [0m[1;33m   [0muse to globally change the currently active font that LÖVE2D is using to render text (functioning like a state machine).            
[1;33m • [0m[97;40mlove.graphics.setFont(font)[0m                                                                                                            
[1;33m   [0m[1;33m • [0mThis function sets LÖVE2D’s currently active font (of which there can only be one at a time) to a passed-in [97;40mfont[0m object that we can 
[1;33m   [0m[1;33m   [0mcreate using [97;40mlove.graphics.newFont[0m , per the above.                                                                                 
[1;33m • [0m[97;40mlove.graphics.clear(r, g, b, a)[0m                                                                                                        
[1;33m   [0m[1;33m • [0mThis function wipes the entire screen with a color defined by an RGBA set, with each component ranging from 0-255.                  
[1;33m • [0m[97;40mlove.graphics.rectangle(mode, x, y, width, height)[0m                                                                                     
[1;33m   [0m[1;33m • [0mDraws a rectangle onto the screen using whichever our active color is (per [97;40mlove.graphics.setColor[0m , which we don’t need to use in   
[1;33m   [0m[1;33m   [0mthis particular project since most everything is white, the default LÖVE2D color). The [97;40mmode[0m parameter can be set to [97;40mfill[0m or [97;40mline[0m ,  
[1;33m   [0m[1;33m   [0mwhich results in a filled or outlined rectangle, respectively, and the other four parameters are its position and size dimensions.  
[1;33m   [0m[1;33m   [0mThis is the cornerstone drawing function of the entirety of our Pong implementation!                                                

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mAlongside our [97;40mmain.lua[0m file and the [97;40mpush[0m library, you’ll find that we’ve added a font file to our project.                             
[1;33m • [0mOn that note, you’ll find a small addition to our [97;40mlove.load()[0m function:                                                                

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  smallFont = love.graphics.newFont('font.ttf', 8)                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.setFont(smallFont)                                                                                                    [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

This will allow us to create a custom font object (based off the font file we’ve added to our project directory) that we can set as the   
active font in our game.                                                                                                                  

[1;33m • [0mThe only other changes to the code in this update can be found in the [97;40mlove.draw()[0m function.                                            

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  love.graphics.clear(40/255, 45/255, 52/255, 255/255)                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.printf('Hello Pong!', 0, 20, VIRTUAL\_WIDTH, 'center')                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.rectangle('fill', 10, 30, 5, 20)                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.rectangle('fill', VIRTUAL\_WIDTH - 10, VIRTUAL\_HEIGHT - 50, 5, 20)                                                   [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.rectangle('fill', VIRTUAL\_WIDTH / 2 - 2, VIRTUAL\_HEIGHT / 2 - 2, 4, 4)                                              [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

As you can see, we are setting the background to a dark color, shifting “Hello Pong!” higher up on the screen, and drawing rectangles for 
the paddles and the ball. The paddles are positioned on opposing ends of the screen, and the ball in the center.                          


                                                       [1;4mpong-3 (“The Paddle Update”)[0m                                                       

[1;33m • [0mpong-3 adds interactivity to the Paddles by letting us move them up and down using the [97;40mw[0m and [97;40ms[0m keys for the left Paddle and the up and 
[1;33m   [0mdown keys for the right Paddle.                                                                                                        

                                                                                                                                          

Important Functions                                                                                                                       

[1;33m • [0m[97;40mlove.keyboard.isDown(key)[0m                                                                                                              
[1;33m   [0m[1;33m • [0mThis function returns true or false depending on whether the specified key is currently held down; it differs from                  
[1;33m   [0m[1;33m   [0m[97;40mlove.keypressed(key)[0m in that this can be called arbitrarily and will continuously return true if the key is pressed down, whereas   
[1;33m   [0m[1;33m   [0m[97;40mlove.keypressed(key)[0m will only fire its code once every time the key is initially pressed down. However, since we want to be able to
[1;33m   [0m[1;33m   [0mmove our paddles up and down by holding down the appropriate keys, we need a function to test for longer periods of input, hence the
[1;33m   [0m[1;33m   [0muse of [97;40mlove.keyboard.isDown(key)[0m .                                                                                                  

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mYou’ll notice we’ve added a new constant near the top of [97;40mmain.lua[0m :                                                                    

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  PADDLE\_SPEED = 200                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

This is an arbitrary value that we’ve chosen for our paddle speed. It will be scaled by DeltaTime, so it’ll be multiplied by how much time
has passed (in terms of seconds) since the last frame, so that our paddle movement will remain consistent regardless of how quickly or    
slowly our computer is running.                                                                                                           

[1;33m • [0mYou’ll also find some new variables in [97;40mlove.load()[0m :                                                                                   

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  scoreFont = love.graphics.newFont('font.ttf', 32)                                                                                   [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  player1Score = 0                                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  player2Score = 0                                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  player1Y = 30                                                                                                                       [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  player2Y = VIRTUAL\_HEIGHT - 50                                                                                                     [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

In particular, we’ve created a new font object that is of larger size so that we can display each player’s score more visibly on the      
screen, and allocated two variables for the purpose of scorekeeping. The last two variables will keep track of each paddle’s vertical     
position, since the paddles will be able to move up and down.                                                                             

[1;33m • [0mNext, you’ll see that we’ve finally defined behavior for [97;40mlove.update()[0m :                                                               

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  function love.update(dt)                                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      if love.keyboard.isDown('w') then                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          player1Y = player1Y + -PADDLE\_SPEED \* dt                                                                                  [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      elseif love.keyboard.isDown('s') then                                                                                           [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          player1Y = player1Y + PADDLE\_SPEED \* dt                                                                                   [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      if love.keyboard.isDown('up') then                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          player2Y = player2Y + -PADDLE\_SPEED \* dt                                                                                  [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      elseif love.keyboard.isDown('down') then                                                                                        [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          player2Y = player2Y + PADDLE\_SPEED \* dt                                                                                   [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

Here, we’ve implemented a way for each player to move their paddle. Recall that our 2D coordinate system is centered at the top left of   
the screen. Therefore, in order for each paddle to move upwards, its Y position will need to be multiplied by negative velocity (and vice 
versa), which might seem counterintuitive at first glance, so be sure to take a moment to look at this carefully.                         

[1;33m • [0mLastly, in [97;40mlove.draw()[0m you’ll see that we’ve added code for displaying the score on the screen:                                        

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  love.graphics.setFont(scoreFont)                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.print(tostring(player1Score), VIRTUAL\_WIDTH / 2 - 50, VIRTUAL\_HEIGHT / 3)                                           [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.print(tostring(player2Score), VIRTUAL\_WIDTH / 2 + 30, VIRTUAL\_HEIGHT / 3)                                           [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

First we set the active font to be the larger of the two we’ve created, and then we display each player’s score on their side of the      
screen.                                                                                                                                   


                                                        [1;4mpong-4 (“The Ball Update”)[0m                                                        

[1;33m • [0mpong-4 adds motion to the Ball upon the user pressing [97;40menter[0m .                                                                          

                                                                                                                                          

Important Functions                                                                                                                       

[1;33m • [0m[97;40mmath.randomseed(num)[0m                                                                                                                   
[1;33m   [0m[1;33m • [0mThis function “seeds” the random number generator used by Lua ( [97;40mmath.random[0m ) with some values such that its randomness is dependent
[1;33m   [0m[1;33m   [0mon that supplied value, allowing us to pass in different numbers each playthrough to guarantee non-consistency across different     
[1;33m   [0m[1;33m   [0mprogram executions (or uniformity if we want consistent behavior for testing).                                                      
[1;33m • [0m[97;40mos.time()[0m                                                                                                                              
[1;33m   [0m[1;33m • [0mThis is a Lua function that returns, in seconds, the time since 00:00:00 UTC, January 1, 1970, also known as Unix epoch time (      
[1;33m   [0m[1;33m   [0m]8;id=696507;https://en.wikipedia.ord/wiki/Unix_time\[94men.wikipedia.ord/wiki/Unix[0m]8;;\]8;id=696507;https://en.wikipedia.ord/wiki/Unix_time\[94m_[0m]8;;\]8;id=696507;https://en.wikipedia.ord/wiki/Unix_time\[94mtime[0m]8;;\ )                                                                                                   
[1;33m • [0m[97;40mmath.random(min, max)[0m                                                                                                                  
[1;33m   [0m[1;33m • [0mThis function returns a random number, dependent on the seeded random number generator, between [97;40mmin[0m and [97;40mmax[0m , inclusive.            
[1;33m • [0m[97;40mmath.min(num1, num2)[0m                                                                                                                   
[1;33m   [0m[1;33m • [0mReturns the lesser of the two numbers passed in.                                                                                    
[1;33m • [0m[97;40mmath.max(num1, num2)[0m                                                                                                                   
[1;33m   [0m[1;33m • [0mReturns the greater of the two numbers passed in.                                                                                   

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mYou’ll find our first addition to the code at the top of [97;40mlove.load()[0m :                                                                 

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  math.randomseed(os.time())                                                                                                          [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

This seeds the random number generator, using the current time to ensure different random numbers each time our game is run. Beyond that, 
you’ll see a few new variables near the bottom of [97;40mlove.load()[0m :                                                                           

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  ballX = VIRTUAL\_WIDTH / 2 - 2                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  ballY = VIRTUAL\_HEIGHT / 2 - 2                                                                                                     [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  ballDX = math.random(2) == 1 and 100 or -100                                                                                        [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  ballDY = math.random(-50, 50)                                                                                                       [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  gameState = 'start'                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

[97;40mballX[0m and [97;40mballY[0m will keep track of the ball position, while [97;40mballDX[0m and [97;40mballDY[0m will keep track of the ball velocity. [97;40mgameState[0m will serve  
as a rudimentary “state machine”, such that we’ll cycle it through the different states of our game (start, play, etc.)                   

[1;33m • [0mIn [97;40mlove.update()[0m , we tweak our code for paddle movement by wrapping it around the [97;40mmath.max()[0m and [97;40mmath.min[0m functions to ensure that the
[1;33m   [0mpaddles can’t move beyond the edges of the screen:                                                                                     
[1;33m • [0mWe also add new code to ensure the ball can only move when we are in the “play” state:                                                 

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  if gameState == 'play' then                                                                                                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ballX = ballX + ballDX \* dt                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ballY = ballY + ballDY \* dt                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

[1;33m • [0mFollowing this, in [97;40mlove.keypressed(key)[0m , we add functionality to launch the game (thus transitioning from the “start” state to the    
[1;33m   [0m“play” state) and implement ball movement mechanics:                                                                                   

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  elseif key == 'enter' or key == 'return' then                                                                                       [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      if gameState == 'start' then                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          gameState = 'play'                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      else                                                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          gameState = 'start'                                                                                                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ballX = VIRTUAL\_WIDTH / 2 - 2                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ballY = VIRTUAL\_HEIGHT / 2 - 2                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ballDX = math.random(2) == 1 and 100 or -100                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ballDY = math.random(-50, 50) \* 1.5                                                                                        [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

Once in the “play state,” we start the ball’s position in the center of the screen and assign it a random starting velocity.              

[1;33m • [0mLastly, we tweak our [97;40mlove.draw()[0m function so that we can see the changes from [97;40mlove.update()[0m at each frame:                             

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  if gameState == 'start' then                                                                                                        [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.printf('Hello Start State!', 0, 20, VIRTUAL\_WIDTH, 'center')                                                     [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  else                                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.printf('Hello Play State!', 0, 20, VIRTUAL\_WIDTH, 'center')                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.rectangle('fill', 10, player1Y, 5, 20)                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.rectangle('fill', VIRTUAL\_WIDTH - 10, player2Y, 5, 20)                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  love.graphics.rectangle('fill', ballX, ballY, 4, 4)                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

The only changes of note are the displaying of different messages depending on the game state, and updating the previous print statements 
to use the variables dynamically keeping track of position, rather than static values.                                                    


                                                       [1;4mpong-5 (“The Class Update”)[0m                                                        

[1;33m • [0mpong-5 behaves exactly like pong-4. The biggest advantage we gain from this update is in the design of our code.                       
[1;33m • [0mOpen up pong-5 to take a look at how we’ve reorganized the code using classes and objects.                                             

                                                                                                                                          

What is a class?                                                                                                                          

[1;33m • [0mA class is essentially a container for attributes (i.e., values or fields) and methods (i.e., functions). You can think of it as a     
[1;33m   [0mblueprint for creating bundles of data and code that are related to each other.                                                        
[1;33m • [0mEx: A “Car” class can have “attributes” that describe its brand, model, color, miles, and anything else descriptive. Similarly, a “Car”
[1;33m   [0mclass can also have “methods” that define its behavior, such as “accelerate”, “turn”, “honk”, and more, which take the form of         
[1;33m   [0mfunctions.                                                                                                                             
[1;33m • [0mObjects are instantiated from these class blueprints, and it’s these concrete objects that are the physical “cars” you see on the road,
[1;33m   [0mas opposed to the blueprints that may exist in the factory.                                                                            
[1;33m • [0mOur Paddles and Ball are perfect simple use cases for taking some of our code and bundling it together into classes and objects.       
[1;33m • [0mIn Lua, class filenames are capitalized by convention, which helps you differentiate between any classes and libraries which you might 
[1;33m   [0mbe including in the same directory as your [97;40mmain.lua[0m file.                                                                              
[1;33m • [0mAlso note that we [97;40mrequire[0m our class files in [97;40mmain.lua[0m just as we do for libraries. Additionally, we [97;40mrequire[0m a [97;40mclass[0m library which      
[1;33m   [0mcontains helpful functionality for object-oriented programming in Lua.                                                                 

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mThe main takeaway from this update is that we now have abstracted away from [97;40mmain.lua[0m the logic relevant to paddle and ball mechanics.  
[1;33m   [0mThese are now in their own classes, so you’ll see a few new files in the project directory. [97;40mBall.lua[0m contains all the logic specific to
[1;33m   [0mthe ball, while [97;40mPaddle.lua[0m contains all the logic specific to each paddle. You’ll also find [97;40mclass.lua[0m which is what allows us to do    
[1;33m   [0mthis.                                                                                                                                  
[1;33m • [0mThis not only gives us greater flexibility moving forward, it also makes our [97;40mmain.lua[0m file cleaner and more readable.                  


                                                        [1;4mpong-6 (“The FPS Update”)[0m                                                         

[1;33m • [0mpong-6 adds a title to our screen and displays the FPS of our application on the screen as well                                        

                                                                                                                                          

Important Functions                                                                                                                       

[1;33m • [0m[97;40mlove.window.setTitle(title)[0m                                                                                                            
[1;33m   [0m[1;33m • [0mThis function sets the title of our application window, adding a slight level of polish.                                            
[1;33m • [0m[97;40mlove.timer.getFPS()[0m                                                                                                                    
[1;33m   [0m[1;33m • [0mReturns the current FPS (frames per second) of our application, making it easy to monitor when printed.                             

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mOur first addition to the code is in [97;40mlove.load()[0m :                                                                                     

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  love.window.setTitle('Pong')                                                                                                        [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

This quick and easy one-liner sets the title of our window.                                                                               

[1;33m • [0mOur second addition to the code is at the very bottom of [97;40mmain.lua[0m . We define a helper function to display our FPS onto the screen:    

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  function displayFPS()                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.setFont(smallFont)                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.setColor(0, 255/255, 0, 255/255)                                                                                  [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.print('FPS: ' .. tostring(love.timer.getFPS()), 10, 10)                                                           [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

We then call this helper function in [97;40mlove.draw()[0m .                                                                                        


                                                     [1;4mpong-7 (“The Collision Update”)[0m                                                      

[1;33m • [0mpong-7 allows for the Ball to bounce off the Paddles and window boundaries.                                                            
[1;33m • [0mOpen up pong-7 to take a look at how we’ve incorporated AABB Collision Detection into our Pong program.                                

                                                                                                                                          

AABB Collision Detection                                                                                                                  

[1;33m • [0mAABB Collision Detection relies on all colliding entities to have “axis-aligned bounding boxes”, which simply means their collision    
[1;33m   [0mboxes contain no rotation in our world space, which allows us to use a simple math formula to test for collision:                      

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  if rect1.x is not > rect2.x + rect2.width and                                                                                       [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      rect1.x + rect1.width is not < rect2.x and                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      rect1.y is not > rect2.y + rect2.height and                                                                                     [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      rect1.y + rect1.height is not < rect2.y:                                                                                        [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      collision is true                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  else                                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      collision is false                                                                                                              [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

Essentially, the formula is merely checking if the two boxes are colliding in any way.                                                    

[1;33m • [0mWe can use AABB Collision Detection to detect whether our Ball is colliding with our Paddles and react accordingly.                    
[1;33m • [0mWe can apply similar logic to detect if the Ball collides with a window boundary.                                                      

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mNotice how we’ve added a [97;40mcollides[0m function to our Ball class. It uses the above algorithm to determine whether there has been a        
[1;33m   [0mcollision, returning [97;40mtrue[0m if so and [97;40mfalse[0m otherwise.                                                                                   
[1;33m • [0mWe can use this function in [97;40mlove.update()[0m to keep track of the ball’s changing position and velocity after each collision with a       
[1;33m   [0mpaddle:                                                                                                                                

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  if ball:collides(player1) then                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball.dx = -ball.dx \* 1.03                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball.x = player1.x + 5                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      if ball.dy < 0 then                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ball.dy = -math.random(10, 150)                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      else                                                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ball.dy = math.random(10, 150)                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  if ball:collides(player2) then                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball.dx = -ball.dx \* 1.03                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball.x = player2.x - 4                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      if ball.dy < 0 then                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ball.dy = -math.random(10, 150)                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      else                                                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ball.dy = math.random(10, 150)                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

Take special note of how we shift the ball away from the paddle first before reversing its direction if we detect a collision in which the
ball and paddle’s edges overlap! This prevents an infinite collision loop between the ball and paddle.                                    

[1;33m • [0mWe also implement similar logic for collisions with the window edges:                                                                  

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  if ball.y <= 0 then                                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball.y = 0                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball.dy = -ball.dy                                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  if ball.y >= VIRTUAL\_HEIGHT - 4 then                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball.y = VIRTUAL\_HEIGHT - 4                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball.dy = -ball.dy                                                                                                              [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m


                                                       [1;4mpong-8 (“The Score Update”)[0m                                                        

[1;33m • [0mpong-8 allows us to keep track of the score.                                                                                           

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mEssentially, all we need to do is increment the score variables for each player whenever the ball collides with their goal boundary:   

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  if ball.x < 0 then                                                                                                                  [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      servingPlayer = 1                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      player2Score = player2Score + 1                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball:reset()                                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      gameState = 'start'                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  if ball.x > VIRTUAL\_WIDTH then                                                                                                     [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      servingPlayer = 2                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      player1Score = player1Score + 1                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball:reset()                                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      gameState = 'start'                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m


                                                       [1;4mpong-9 (“The Serve Update”)[0m                                                        

[1;33m • [0mpong-9 introduces a new state, “serve”, to our game.                                                                                   

                                                                                                                                          

What is a State Machine?                                                                                                                  

[1;33m • [0mCurrently in our Pong program we’ve only talked about state a little bit. We have our “start” state, which means the game is ready for 
[1;33m   [0mus to press “enter” so that the ball will start moving, and our “play” state, which means the game is currently underway.              
[1;33m • [0mA state machine concerns itself with monitoring what is the current state and what transitions take place between possible states, such
[1;33m   [0mthat each individual state is produced by a specific transition and has its own logic.                                                 
[1;33m • [0mIn pong-9, we allow a player to “serve” the ball by not having to defend during their first turn.                                      
[1;33m • [0mWe transition from the “play” state to the “serve” state by scoring, and from the “serve” state to the “play” state by pressing [97;40menter[0m .
[1;33m   [0mThe game begins in the “start” state, and transitions to the serve state by pressing [97;40menter[0m .                                           

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mWe can essentially add our new “serve” state by making an additional condition within our [97;40mlove.update()[0m function:                      

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  if gameState == 'serve' then                                                                                                        [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ball.dy = math.random(-50, 50)                                                                                                  [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      if servingPlayer == 1 then                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ball.dx = math.random(140, 200)                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      else                                                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ball.dx = -math.random(140, 200)                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  elseif ...                                                                                                                          [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

The idea is that when a player gets scored on, they should get to serve the ball, so as to not be immediately on defense. We do this by   
adjusting the ball velocity in the “serve” state based off which player is serving.                                                       


                                                      [1;4mpong-10 (“The Victory Update”)[0m                                                      

[1;33m • [0mpong-10 allows a player to win the game.                                                                                               

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mWe introduce a new state: “done”, and then we set a maximum score (in our case, 10). Within [97;40mlove.update()[0m , we modify our code that    
[1;33m   [0mchecks whether a point has been scored as follows:                                                                                     

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  if ball.x < 0 then                                                                                                                  [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      servingPlayer = 1                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      player2Score = player2Score + 1                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      if player2Score == 10 then                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          winningPlayer = 2                                                                                                           [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          gameState = 'done'                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      else                                                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          gameState = 'serve'                                                                                                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ball:reset()                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  if ball.x > VIRTUAL\_WIDTH then                                                                                                     [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      servingPlayer = 2                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      player1Score = player1Score + 1                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      if player1Score == 10 then                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          winningPlayer = 1                                                                                                           [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          gameState = 'done'                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      else                                                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          gameState = 'serve'                                                                                                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ball:reset()                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

[1;33m • [0mWhen a player reaches the maximum score, the game state transitions to “done” and we produce a victory screen in [97;40mlove.draw()[0m :         

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  elseif gameState == 'done' then                                                                                                     [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.setFont(largeFont)                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.printf('Player ' .. tostring(winningPlayer) .. ' wins!', 0, 10, VIRTUAL\_WIDTH, 'center')                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.setFont(smallFont)                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      love.graphics.printf('Press Enter to restart!', 0, 30, VIRTUAL\_WIDTH, 'center')                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

[1;33m • [0mFinally, we add some code to [97;40mlove.keypressed(key)[0m to transition back to the “serve” state and reset the scores in case the player(s)   
[1;33m   [0mwould like to play again.                                                                                                              

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  elseif key == 'enter' or key == 'return' then                                                                                       [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ...                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      elseif gameState == 'done' then                                                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          gameState = 'serve'                                                                                                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          ball:reset()                                                                                                                [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          player1Score = 0                                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          player2Score = 0                                                                                                            [0m [2m│[0m
[2m│[0m [48;2;39;40;34m                                                                                                                                      [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          if winningPlayer == 1 then                                                                                                  [0m [2m│[0m
[2m│[0m [48;2;39;40;34m              servingPlayer = 2                                                                                                       [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          else                                                                                                                        [0m [2m│[0m
[2m│[0m [48;2;39;40;34m              servingPlayer = 1                                                                                                       [0m [2m│[0m
[2m│[0m [48;2;39;40;34m          end                                                                                                                         [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      end                                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m


                                                       [1;4mpong-11 (“The Audio Update”)[0m                                                       

[1;33m • [0mpong-11 adds sound to the game                                                                                                         

                                                                                                                                          

Important Functions                                                                                                                       

[1;33m • [0m[97;40mlove.audio.newSource(path, [type])[0m                                                                                                     
[1;33m   [0m[1;33m • [0mThis function creates a LÖVE2D Audio object that we can play back at any point in our program. It can also be given a “type” of     
[1;33m   [0m[1;33m   [0m“stream” or “static”; streamed assets will be streamed from disk as needed, whereas static assets will be preserved in memory. For  
[1;33m   [0m[1;33m   [0mlarger sound effects and music tracks, streaming is more memory-effective; in our examples, audio assets are static, since they’re  
[1;33m   [0m[1;33m   [0mso small that they won’t take up much memory at all                                                                                 
[1;33m   [0m[1;33m • [0mWe will use this functionality to play a sound whenever there is a collision.                                                       

                                                                                                                                          

What is bfxr?                                                                                                                             

[1;33m • [0mbfxr is a simple program for generating random sounds, freely-available on all major Operating Systems.                                
[1;33m • [0mWe will use it to generate all sound effects for our Pong example and most other examples going forward.                               
[1;33m • [0m]8;id=465230;https://www.bfxr.net/\[94mbfxr.net[0m]8;;\                                                                                                                               
[1;33m • [0mWe’ve created 3 sound files and stored them in a sub-directory within pong-11.                                                         

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mYou’ll notice in [97;40mlove.load()[0m that we’ve created a table with references to the 3 sound files we’ve added to our project directory:     

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  sounds = {                                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ['paddle\_hit'] = love.audio.newSource('sounds/paddle\_hit.wav', 'static'),                                                     [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ['score'] = love.audio.newSource('sounds/score.wav', 'static'),                                                                 [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      ['wall\_hit'] = love.audio.newSource('sounds/wall\_hit.wav', 'static')                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  }                                                                                                                                   [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

In this case, we are storing each sound as a “static” audio file because of how small they are. In the future, if using larger audio      
files, you might consider storing them as “stream” audio files so as to save on memory.                                                   

[1;33m • [0mYou should be able to find throughout the rest of [97;40mmain.lua[0m function calls such as [97;40msounds['paddle_hit']:play()[0m in locations             
[1;33m   [0mcorresponding to playing sound upon paddle collisions, wall collisions, and scoring points.                                            


                                                      [1;4mpong-12 (“The Resize Update”)[0m                                                       

[1;33m • [0mpong-12 allows our Pong program to support resizing the window.                                                                        

                                                                                                                                          

Important Functions                                                                                                                       

[1;33m • [0m[97;40mlove.resize(width, height)[0m                                                                                                             
[1;33m   [0m[1;33m • [0mThis function is called by LÖVE every time we resize the application; logic should go in here if anything in the game (like a UI) is
[1;33m   [0m[1;33m   [0msized dynamically based on the window size. [97;40mpush:resize()[0m needs to be called here for our use case so that it can dynamically       
[1;33m   [0m[1;33m   [0mrescale its internal canvas to fit our new window dimensions.                                                                       

                                                                                                                                          

Important Code                                                                                                                            

[1;33m • [0mIn order to support resizing the game window, we’ll first need to edit our window initialization in [97;40mlove.load()[0m such that [97;40mresizable = [0m 
[1;33m   [0m[97;40mtrue[0m :                                                                                                                                 

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  push:setupScreen(VIRTUAL\_WIDTH, VIRTUAL\_HEIGHT, WINDOW\_WIDTH, WINDOW\_HEIGHT, {                                                  [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      fullscreen = false,                                                                                                             [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      resizable = true,                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      vsync = true                                                                                                                    [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  })                                                                                                                                  [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

[1;33m • [0mThe next step is to overwrite [97;40mlove.resize()[0m with its analog from the [97;40mpush[0m library:                                                     

[2m┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐[0m
[2m│[0m [48;2;39;40;34m  function love.resize(w, h)                                                                                                          [0m [2m│[0m
[2m│[0m [48;2;39;40;34m      push:resize(w, h)                                                                                                               [0m [2m│[0m
[2m│[0m [48;2;39;40;34m  end                                                                                                                                 [0m [2m│[0m
[2m└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘[0m

And with that, we have a fully functioning game of Pong!                                                                                  
